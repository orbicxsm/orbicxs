-- 1. Profiles jadvali (foydalanuvchilar)
create table if not exists public.profiles (
  id uuid references auth.users not null primary key,
  username text unique,
  avatar_url text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Username bo'yicha unikal indeks
create unique index if not exists profiles_username_idx on public.profiles (lower(username));

-- RLS (Row Level Security) yoqish
alter table public.profiles enable row level security;

-- Har kim o'z profilini o'qiy oladi
create policy "Profiles o'qish" on public.profiles
  for select using (true);

-- Faqat o'zi yangilay oladi
create policy "Profilni yangilash" on public.profiles
  for update using (auth.uid() = id);

-- Faqat o'zi qo'sha oladi (birinchi marta)
create policy "Profil qo'shish" on public.profiles
  for insert with check (auth.uid() = id);

-- 2. Messages jadvali (xabarlar)
create table if not exists public.messages (
  id bigint generated by default as identity primary key,
  chat_id text not null,
  sender text not null,
  text text,
  image_url text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Chat_id va vaqt bo'yicha indeks (tez yuklash uchun)
create index if not exists messages_chat_id_idx on public.messages (chat_id, created_at desc);

-- RLS yoqish
alter table public.messages enable row level security;

-- Chat ishtirokchilari xabarlarni ko'ra oladi
create policy "Xabarlarni o'qish" on public.messages
  for select using (
    chat_id = (select lower(concat(sort(array[auth.jwt()->>'username', split_part(chat_id, '_', 1)], array[auth.jwt()->>'username', split_part(chat_id, '_', 2)])))::text || '_' || 
    lower(concat(sort(array[auth.jwt()->>'username', split_part(chat_id, '_', 2)], array[auth.jwt()->>'username', split_part(chat_id, '_', 1)])))::text))
    or chat_id like '%' || (auth.jwt()->>'username') || '%'
  );

-- Faqat chat ishtirokchilari yozishi mumkin
create policy "Xabar yozish" on public.messages
  for insert with check (
    sender = (auth.jwt()->>'username')
    and chat_id like '%' || sender || '%'
  );

-- 3. Push subscriptions (bildirishnomalar uchun)
create table if not exists public.push_subscriptions (
  user_id uuid references auth.users not null primary key,
  subscription jsonb not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table public.push_subscriptions enable row level security;

create policy "Push o'qish" on public.push_subscriptions
  for select using (auth.uid() = user_id);

create policy "Push qo'shish/yangilash" on public.push_subscriptions
  for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- 4. Realtime yoqish (Supabase Realtime uchun)
alter publication supabase_realtime add table public.messages;
alter publication supabase_realtime add table public.profiles;

-- 5. Storage bucket'lar yaratish (Storage → SQL orqali emas, lekin bu yerda eslatma)
-- Supabase dashboard → Storage da quyidagi bucket'larni yarating:

-- Bucket 1: avatars
--   Public: Yes (yoki No + signed URL ishlatish)
--   Allowed MIME types: image/*

-- Bucket 2: chat-images
--   Public: Yes
--   Allowed MIME types: image/*

-- Storage RLS siyosatlari (Storage → Policies da qo'lda qo'shing yoki SQL orqali):
-- avatars uchun:
create policy "Avatar upload"
  on storage.objects for insert
  with check (
    bucket_id = 'avatars'
    and (storage.foldername(name))[1] is null
    and auth.uid()::text = (storage.foldername(name))[1]
  );

create policy "Avatar read"
  on storage.objects for select
  using (bucket_id = 'avatars');

-- chat-images uchun:
create policy "Chat image upload"
  on storage.objects for insert
  with check (
    bucket_id = 'chat-images'
    and (storage.foldername(name))[1] = 'chat'
  );

create policy "Chat image read"
  on storage.objects for select
  using (bucket_id = 'chat-images');

-- Muhim: auth.jwt() da username bo'lishi uchun trigger kerak
-- (Supabase auth.users da username yo'q, shuning uchun profiles dan olinadi)

create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id)
  values (new.id)
  on conflict (id) do nothing;
  return new;
end;
$$ language plpgsql security definer;

-- Trigger yaratish
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
